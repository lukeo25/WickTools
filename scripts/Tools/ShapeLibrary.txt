<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Shape Library</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; padding:0; height:100%; background:#111; color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  .wrap { height:100%; display:flex; flex-direction:column; }
  .top { padding:10px 12px; border-bottom:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .title { font-size:16px; font-weight:700; letter-spacing:0.3px; }
  .mode { display:inline-flex; align-items:center; gap:10px; font-size:13px; opacity:0.95; user-select:none; }
  .seg { display:inline-flex; border:1px solid rgba(255,255,255,0.12); border-radius:10px; overflow:hidden; }
  .seg button { appearance:none; border:0; background:transparent; color:#ddd; padding:7px 10px; font-size:13px; cursor:pointer; }
  .seg button.active { background:rgba(255,255,255,0.10); color:#fff; }
  .catBar { padding:8px 12px; border-bottom:1px solid rgba(255,255,255,0.08); display:flex; gap:8px; flex-wrap:wrap; } /* FIX */
  .catBtn { border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.03); color:#ddd; border-radius:999px; padding:6px 10px; font-size:12px; cursor:pointer; } /* FIX */
  .catBtn.active { background:rgba(255,255,255,0.10); color:#fff; } /* FIX */
  .grid { flex:1 1 auto; padding:12px; display:grid; grid-template-columns:repeat(auto-fill, minmax(64px, 1fr)); grid-auto-rows:72px; gap:10px; overflow:auto; } /* FIX */
  .shapeBtn { height:72px; width:100%; border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.03); border-radius:14px; display:flex; align-items:center; justify-content:center; cursor:pointer; overflow:hidden; } /* FIX */
  .shapeBtn:hover { background:rgba(255,255,255,0.07); }
  .shapeBtn { color:#fff; } /* FIX */
  .shapeBtn svg { width:28px; height:28px; color:currentColor; } /* FIX */
  .shapeBtn svg * { fill: none !important; stroke: currentColor !important; } /* FIX */
  .shapeBtn svg { stroke-width: 2; } /* FIX */
  .bottom { padding:10px 12px; border-top:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .status { font-size:12px; opacity:0.85; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; }
  details { margin-left:10px; user-select:none; }
  summary { cursor:pointer; font-size:12px; opacity:0.85; }
  textarea#debugLog { margin-top:6px; width:260px; height:140px; box-sizing:border-box; background:#0b0b0b; color:#d7d7d7; border:1px solid #333; border-radius:8px; padding:8px; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Courier New',monospace; font-size:11px; line-height:1.3; }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="title">Shape Library</div>
    <div class="mode">Place: Clip</div> <!-- FIX -->
  </div>

  <div id="catBar" class="catBar" aria-label="Folders"></div> <!-- FIX -->


  <div id="grid" class="grid" aria-label="Shapes"></div>

  <div class="bottom">
    <div id="status" class="status">Ready</div>
    <details id="dbgWrap">
      <summary>Details</summary>
      <textarea id="debugLog" readonly></textarea>
    </details>
  </div>
</div>

<script>
(function () {
  "use strict";

  let placeMode = "clip"; // FIX

  const SHAPES = []; // FIX
  // Shapes are fetched dynamically from GitHub. SHAPES is only an optional fallback and is intentionally empty. // FIX

  async function loadShapesFromGithub() { // FIX
    try { // FIX
      const res = await fetch(GITHUB_CONTENTS_API, { cache: "no-store" }); // FIX
      if (!res.ok) throw new Error("GitHub API HTTP " + res.status); // FIX
      const items = await res.json(); // FIX
      if (!Array.isArray(items)) throw new Error("GitHub API unexpected response"); // FIX
      const svgs = items
        .filter(it => it && typeof it.name === "string" && it.name.toLowerCase().endsWith(".svg") && typeof it.download_url === "string") // FIX
        .map(it => ({ // FIX
          name: filenameToDisplayName(it.name), // FIX
          file: it.name, // FIX
          url: it.download_url // FIX
        })) // FIX
        .sort((a, b) => a.name.localeCompare(b.name)); // FIX
      if (svgs.length === 0) throw new Error("No SVG files found"); // FIX
      return svgs; // FIX
    } catch (e) { // FIX
      console.warn("[ShapeLibrary] Falling back to built in SHAPES:", e); // FIX
      return SHAPES.map(s => ({ name: s.name, file: s.file, url: BASE_PATH + "/" + s.file })); // FIX
    } // FIX
  } // FIX

  function filenameToDisplayName(fileName) { // FIX
    const base = String(fileName).replace(/\.svg$/i, ""); // FIX
    const spaced = base.replace(/[_\-]+/g, " ").trim(); // FIX
    return spaced ? spaced : base; // FIX
  } // FIX

  async function loadShapeGroupsFromGithub() { // FIX
    try { // FIX
      async function listDir(relPath) { // FIX
        const segs = String(relPath || "").split("/").filter(Boolean).map(encodeURIComponent).join("/"); // FIX
        const url = "https://api.github.com/repos/lukeo25/WickTools/contents/scripts/Panel_SVG/Shapes" + (segs ? ("/" + segs) : "") + "?ref=main"; // FIX
        const res = await fetch(url, { cache: "no-store", headers: { "Accept": "application/vnd.github+json" } }); // FIX
        if (!res.ok) throw new Error("GitHub API HTTP " + res.status); // FIX
        const items = await res.json(); // FIX
        if (!Array.isArray(items)) throw new Error("GitHub API unexpected response"); // FIX
        return items; // FIX
      } // FIX

      async function collectSvgsRecursive(relPath, depth) { // FIX
        if (depth > 6) return []; // FIX
        const items = await listDir(relPath); // FIX
        const svgsHere = items // FIX
          .filter(it => it && typeof it.name === "string" && it.name.toLowerCase().endsWith(".svg") && typeof it.download_url === "string") // FIX
          .map(it => ({ // FIX
            name: filenameToDisplayName(it.name), // FIX
            file: (relPath ? (relPath + "/") : "") + it.name, // FIX
            url: it.download_url // FIX
          })); // FIX

        const dirs = items // FIX
          .filter(it => it && it.type === "dir" && typeof it.name === "string") // FIX
          .map(it => it.name); // FIX

        let all = svgsHere.slice(); // FIX
        for (const d of dirs) { // FIX
          const childRel = (relPath ? (relPath + "/") : "") + d; // FIX
          const childSvgs = await collectSvgsRecursive(childRel, depth + 1); // FIX
          all = all.concat(childSvgs); // FIX
        } // FIX
        return all; // FIX
      } // FIX

      function sortByName(list) { // FIX
        return (list || []).sort((a,b)=>String(a.name).localeCompare(String(b.name))); // FIX
      } // FIX

      const groups = {}; // FIX
      groups["All"] = []; // FIX

      // Root SVGs (only files directly in Shapes) // FIX
      const rootItems = await listDir(""); // FIX
      const rootSvgs = rootItems // FIX
        .filter(it => it && typeof it.name === "string" && it.name.toLowerCase().endsWith(".svg") && typeof it.download_url === "string") // FIX
        .map(it => ({ name: filenameToDisplayName(it.name), file: it.name, url: it.download_url })); // FIX
      if (rootSvgs.length) { // FIX
        groups["Root"] = sortByName(rootSvgs); // FIX
        groups["All"].push(...groups["Root"]); // FIX
      } // FIX

      // Top level folders become tabs, each tab includes all SVGs in its subtree // FIX
      const topDirs = rootItems // FIX
        .filter(it => it && it.type === "dir" && typeof it.name === "string") // FIX
        .map(it => it.name); // FIX

      for (const dirName of topDirs) { // FIX
        const svgs = sortByName(await collectSvgsRecursive(dirName, 0)); // FIX
        if (svgs.length) { // FIX
          groups[dirName] = svgs; // FIX
          groups["All"].push(...svgs); // FIX
        } // FIX
      } // FIX

      if (!groups["All"].length) throw new Error("No SVG files found"); // FIX
      groups["All"] = sortByName(groups["All"]); // FIX
      return groups; // FIX

    } catch (e) { // FIX
      console.warn("[ShapeLibrary] Falling back to empty groups:", e); // FIX
      const fallback = {}; // FIX
      fallback["All"] = []; // FIX
      return fallback; // FIX
    } // FIX
  } // FIX

  function buildCategoryTabs(groups, onSelect) { // FIX
    const bar = document.getElementById("catBar"); // FIX
    if (!bar) return; // FIX
    bar.innerHTML = ""; // FIX
    const names = Object.keys(groups); // FIX
    names.sort((a,b)=>{ // FIX
      if (a === "All") return -1; // FIX
      if (b === "All") return 1; // FIX
      if (a === "Root") return -1; // FIX
      if (b === "Root") return 1; // FIX
      return a.localeCompare(b); // FIX
    }); // FIX
    names.forEach((name, i) => { // FIX
      const btn = document.createElement("button"); // FIX
      btn.type = "button"; // FIX
      btn.className = "catBtn" + (i === 0 ? " active" : ""); // FIX
      btn.textContent = name; // FIX
      btn.addEventListener("click", function () { // FIX
        Array.from(bar.querySelectorAll(".catBtn")).forEach(b => b.classList.remove("active")); // FIX
        btn.classList.add("active"); // FIX
        onSelect(name); // FIX
      }); // FIX
      bar.appendChild(btn); // FIX
    }); // FIX
  } // FIX



  const BASE_PATH = "https://raw.githubusercontent.com/lukeo25/WickTools/main/scripts/Panel_SVG/Shapes"; // FIX
  const GITHUB_CONTENTS_API = "https://api.github.com/repos/lukeo25/WickTools/contents/scripts/Panel_SVG/Shapes?ref=main"; // FIX

  const elGrid   = document.getElementById("grid");
  const elStatus = document.getElementById("status");
  let placeAsClip = true;

  const modeSvgBtn  = document.getElementById("modeSvg");
  const modeClipBtn = document.getElementById("modeClip");

  function setPlaceMode(makeClip) {
    placeAsClip = !!makeClip;
    modeClipBtn?.classList.toggle("active", placeAsClip);
    modeSvgBtn?.classList.toggle("active", !placeAsClip);
  }

  if (modeSvgBtn && modeClipBtn) {
    modeSvgBtn.addEventListener("click", () => setPlaceMode(false));
    modeClipBtn.addEventListener("click", () => setPlaceMode(true));
    setPlaceMode(true);
  }

  function setStatus(msg) {
    elStatus.textContent = msg || "";
  }

  function sleepMs(ms) { // FIX
    return new Promise(function (resolve) { setTimeout(resolve, ms); }); // FIX
  } // FIX

  function debugLog(msg, data) {
    try {
      const line = "[" + new Date().toISOString() + "] " + String(msg);
      const extra = data !== undefined ? " " + JSON.stringify(data, null, 2) : "";
      console.log("ShapeLibrary", line + extra);
      const ta = document.getElementById("debugLog");
      if (ta) {
        ta.value += line + extra + "\n";
        ta.scrollTop = ta.scrollHeight;
      }
    } catch (e) {}
  }

  function parseSvg(svgText) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgText, "image/svg+xml");
    const error = doc.getElementsByTagName("parsererror")[0];
    if (error) throw new Error("SVG parse error");
    return doc;
  }

  function isBadUrlValue(v) {
    const s = String(v || "").trim().toLowerCase();
    return s.startsWith("javascript:") || s.startsWith("http:") || s.startsWith("https:") || s.startsWith("//");
  }

  function stripBadCssUrls(css) {
    return String(css || "")
      .replace(/@import\s+[^;]+;/gi, "")
      .replace(/url\(\s*(['"]?)\s*javascript:[^)]*\)/gi, "url()")
      .replace(/url\(\s*(['"]?)\s*https?:[^)]*\)/gi, "url()")
      .replace(/url\(\s*(['"]?)\s*\/\/[^)]*\)/gi, "url()");
  }

  function sanitizeSvg(svgText) {
    const doc = parseSvg(svgText);
    const svg = doc.documentElement;

    if (svg.nodeName.toLowerCase() !== "svg") throw new Error("Not an SVG root");

    let removedNodes = 0;
    let removedAttrs = 0;

    const bannedTags = [
      "script", "foreignobject", "iframe", "object", "embed",
      "audio", "video", "canvas", "set", "animate", "animatetransform", "animatemotion", "image"
    ];

    function removeAllByTag(tag) {
      const nodes = [...doc.getElementsByTagName(tag)];
      nodes.forEach(n => {
        if (n.parentNode) {
          n.parentNode.removeChild(n);
          removedNodes++;
        }
      });
    }

    bannedTags.forEach(removeAllByTag);
    removeAllByTag("defs");
    removeAllByTag("style");

    const walker = doc.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);
    while (walker.nextNode()) {
      const el = walker.currentNode;
      if (!el.attributes) continue;

      [...el.attributes].forEach(attr => {
        const name = attr.name.toLowerCase();
        const value = attr.value;

        if (name.startsWith("on")) {
          el.removeAttribute(attr.name);
          removedAttrs++;
          return;
        }

        if (name === "href" || name === "xlink:href") {
          if (isBadUrlValue(value)) {
            el.removeAttribute(attr.name);
            removedAttrs++;
          }
        }

        if (name === "style") {
          const cleaned = stripBadCssUrls(value);
          if (cleaned !== value) el.setAttribute("style", cleaned);
        }

        if (["filter", "clip-path", "mask", "fill", "stroke"].includes(name)) {
          if (String(value).toLowerCase().includes("url(")) {
            const cleaned = stripBadCssUrls(value);
            if (cleaned !== value) el.setAttribute(name, cleaned);
          }
        }
      });
    }

    if (!svg.getAttribute("viewBox")) {
      let vb = "0 0 100 100";
      svg.setAttribute("viewBox", vb);
      debugLog("Added fallback viewBox", vb);
    }

    svg.setAttribute("preserveAspectRatio", "none");

    const serializer = new XMLSerializer();
    return {
      text: serializer.serializeToString(doc),
      removedNodes,
      removedAttrs
    };
  }

  function getEditor() {
    const p = window.parent || null;
    if (!p) return null;
    try {
      if (p.wickEditor?.project) return p.wickEditor;
      if (p.wickEditor?.editor?.project) return p.wickEditor.editor;
      if (p.WickEditor?.editor?.project) return p.WickEditor.editor;
      if (p.editor?.project) return p.editor;
      if (p.app?.project) return p.app;
      if (p.app?.editor?.project) return p.app.editor;
    } catch (e) {}
    return null;
  }

  function safeName(s) {
    return String(s || "Shape").replace(/[^a-zA-Z0-9_\s]/g, "").trim().slice(0, 40) || "Shape";
  }

  function listAssetUUIDs(project) {
    try {
      const assets = project?.assets || [];
      if (Array.isArray(assets)) return assets.map(a => a?.uuid).filter(Boolean);
      const out = [];
      for (const k in assets) if (assets[k]?.uuid) out.push(assets[k].uuid);
      return out;
    } catch (e) { return []; }
  }

  function findAssetByName(project, name) {
    try {
      const assets = project?.assets || [];
      if (Array.isArray(assets)) {
        return assets.find(a => a?.name === name || a?.filename === name || a?.identifier === name || a?._identifier === name) || null;
      }
      for (const k in assets) {
        const a = assets[k];
        if (a?.name === name || a?.filename === name || a?.identifier === name || a?._identifier === name) return a;
      }
    } catch (e) {}
    return null;
  }

  function getStageCenter(editor) {
    try {
      const p = editor?.project;
      const w = p?.width || p?.stage?.width || 1920;
      const h = p?.height || p?.stage?.height || 1080;
      return { x: Math.round(w / 2), y: Math.round(h / 2) };
    } catch (e) {}
    return { x: 960, y: 540 };
  }

  const TARGET_PLACED_MAX_PX = 280; // FIX

  function tryGetObjectSize(obj) { // FIX
    try { // FIX
      if (!obj) return null; // FIX
      if (obj.bounds && typeof obj.bounds.width === "number" && typeof obj.bounds.height === "number") { // FIX
        return { w: obj.bounds.width, h: obj.bounds.height }; // FIX
      } // FIX
      if (typeof obj.getBounds === "function") { // FIX
        const b = obj.getBounds(); // FIX
        if (b && typeof b.width === "number" && typeof b.height === "number") return { w: b.width, h: b.height }; // FIX
      } // FIX
      if (typeof obj.getBBox === "function") { // FIX
        const b = obj.getBBox(); // FIX
        if (b && typeof b.width === "number" && typeof b.height === "number") return { w: b.width, h: b.height }; // FIX
      } // FIX
      if (typeof obj.width === "number" && typeof obj.height === "number") { // FIX
        return { w: obj.width, h: obj.height }; // FIX
      } // FIX
      if (obj._width && obj._height) return { w: obj._width, h: obj._height }; // FIX
    } catch (e) {} // FIX
    return null; // FIX
  } // FIX

  function applyUniformScale(obj, factor) { // FIX
    try { // FIX
      if (!obj || !isFinite(factor) || factor <= 0) return false; // FIX
      if (typeof obj.scaleX === "number" && typeof obj.scaleY === "number") { // FIX
        obj.scaleX *= factor; // FIX
        obj.scaleY *= factor; // FIX
        return true; // FIX
      } // FIX
      if (obj.transform && typeof obj.transform.scaleX === "number" && typeof obj.transform.scaleY === "number") { // FIX
        obj.transform.scaleX *= factor; // FIX
        obj.transform.scaleY *= factor; // FIX
        return true; // FIX
      } // FIX
      if (obj._transform && typeof obj._transform.scaleX === "number" && typeof obj._transform.scaleY === "number") { // FIX
        obj._transform.scaleX *= factor; // FIX
        obj._transform.scaleY *= factor; // FIX
        return true; // FIX
      } // FIX
    } catch (e) {} // FIX
    return false; // FIX
  } // FIX

  function resizePlacedObjectToTarget(editor, obj, svgDims) { // FIX
    try { // FIX
      let size = tryGetObjectSize(obj); // FIX
      if (!size) { // FIX
        if (svgDims && isFinite(svgDims.w) && isFinite(svgDims.h)) { // FIX
          size = { w: svgDims.w, h: svgDims.h }; // FIX
          debugLog("Resize using svg dims fallback", size); // FIX
        } else { // FIX
          debugLog("Resize skipped (no bounds available)"); // FIX
          return; // FIX
        } // FIX
      } // FIX
      const maxDim = Math.max(1, size.w, size.h); // FIX
      if ((size.w === 0) || (size.h === 0)) { debugLog("Resize skipped (zero bounds)"); return; } // FIX
      const factor = (maxDim > TARGET_PLACED_MAX_PX) ? (TARGET_PLACED_MAX_PX / maxDim) : 1; // FIX
      debugLog("Resizing placed object", { w: size.w, h: size.h, factor: factor }); // FIX
      const ok = applyUniformScale(obj, factor); // FIX
      if (!ok) debugLog("Resize skipped (no scale fields on object)"); // FIX
      // Recenter after scaling // FIX
      const center = getStageCenter(editor); // FIX
      if (typeof obj.x === "number") obj.x = center.x; // FIX
      if (typeof obj.y === "number") obj.y = center.y; // FIX
    } catch (e) { // FIX
      debugLog("Resize failed", e.message || String(e)); // FIX
    } // FIX
  } // FIX


  function selectSingleObject(editor, obj) {
    try {
      const sel = editor?.selection || editor?.project?.selection;
      if (!sel) return;
      if (typeof sel.clear === 'function') sel.clear();
      if (typeof sel.setSelectedObjects === 'function') return sel.setSelectedObjects([obj]);
      if (Array.isArray(sel.selectedObjects)) sel.selectedObjects = [obj];
    } catch (e) {}
  }

  function setSelectedNameOrIdentifier(editor, name) {
    const n = safeName(name);
    try {
      const sel = editor?.selection || editor?.project?.selection;
      const obj = sel?.selectedObjects?.[0];
      if (!obj) return;
      if ("name"        in obj) obj.name        = n;
      if ("_name"       in obj) obj._name       = n;
      if ("identifier"  in obj) obj.identifier  = n;
      if ("_identifier" in obj) obj._identifier = n;
    } catch (e) {}
  }

  function getCurrentFrameNumber(editor) {
    try {
      const p = editor?.project;
      if (typeof p?.currentFrameNumber === "number") return Math.max(1, Math.floor(p.currentFrameNumber));
      const tl = p?.activeTimeline || p?.timeline;
      if (tl?.playheadPosition != null) return Math.max(1, Math.floor(tl.playheadPosition));
    } catch (e) {}
    return 1;
  }

  function setPlayhead(editor, n) {
    n = Math.max(1, Number(n) || 1);
    try {
      const p = editor?.project;
      if (p) p.currentFrameNumber = n;
      const tl = p?.activeTimeline || p?.timeline;
      if (tl) tl.playheadPosition = n;
    } catch (e) {}
  }

  function forceEnsureActiveFrame(editor, desiredFrameNum) {
    try {
      const project = editor?.project;
      let timeline = project?.activeTimeline || project?.timeline || project?.root?.timeline;
      if (!timeline) return null;

      let layer = timeline.activeLayer;

      if (typeof layer === 'number') {
        const idx = layer;
        if (timeline.layers && Array.isArray(timeline.layers)) {
          layer = timeline.layers[idx] || timeline.layers[0];
        }
      }

      if (!layer || typeof layer !== 'object') return null;

      const n = Math.max(1, Number(desiredFrameNum) || 1);

      let frame = null;

      if (typeof layer.getFrame === 'function') {
        frame = layer.getFrame(n);
      }

      if (!frame && typeof layer.addFrame === 'function') {
        layer.addFrame(n);
        if (typeof layer.getFrame === 'function') frame = layer.getFrame(n);
      }

      if (!frame && layer.frames && Array.isArray(layer.frames)) {
        frame = layer.frames.find(f => f?.start === n);
        if (!frame) {
          frame = { start: n, end: n, content: [] };
          layer.frames.push(frame);
          layer.frames.sort((a,b) => a.start - b.start);
        }
      }

      if (frame && typeof timeline.setActiveFrame === 'function') {
        timeline.setActiveFrame(frame);
      }

      return frame;
    } catch (err) {
      return null;
    }
  }

  async function withSuppressedToasts(editor, fn) {
    if (!editor) return await fn();
    const orig = { toast: editor.toast, updateToast: editor.updateToast };
    try {
      editor.toast = () => {};
      editor.updateToast = () => {};
      return await fn();
    } finally {
      Object.assign(editor, orig);
    }
  }

  async function waitForNewAsset(project, fileName, timeoutMs) { // FIX
    const start = Date.now(); // FIX
    const safeTimeout = Math.max(500, timeoutMs || 4000); // FIX
    while (Date.now() - start < safeTimeout) { // FIX
      try { // FIX
        const asset = findAssetByName(project, fileName); // FIX
        if (asset && asset.uuid) { // FIX
          // Wick sometimes creates the asset record before the internal "published" entry exists. // FIX
          const lib = project?.assetLibrary || project?.assets || null; // FIX
          const byUuid = (typeof project.getAssetByUUID === "function") ? project.getAssetByUUID(asset.uuid) : null; // FIX
          const a = byUuid || asset; // FIX
          const pub = (a && a.file && (a.file.isPublished === true || a.file.isPublished === false)) ? a.file.isPublished : null; // FIX
          // If isPublished exists (true/false), the file entry is no longer null. // FIX
          if (pub !== null) return a; // FIX
        } // FIX
      } catch (e) {} // FIX
      await sleepMs(100); // FIX
    } // FIX
    throw new Error("Timed out waiting for asset to be ready: " + fileName); // FIX
  } // FIX

  function placeImagePathFromAsset(project, assetUuid, x, y) {
    return new Promise((resolve, reject) => {
      try {
        const Wick = window.Wick || window.parent?.Wick;
        if (!Wick || !Wick.ObjectCache || typeof Wick.ObjectCache.getObjectByUUID !== "function") {
          return reject(new Error("Wick.ObjectCache not available"));
        }

        const assetObj = Wick.ObjectCache.getObjectByUUID(assetUuid);
        if (!assetObj) return reject(new Error("Asset not found in cache"));

        if (typeof project.createImagePathFromAsset !== "function") {
          return reject(new Error("createImagePathFromAsset not available"));
        }

        project.createImagePathFromAsset(assetObj, x, y, (path) => {
          resolve(path);
        });
      } catch (err) {
        reject(err);
      }
    });
  }

  async function placeSvgAssetOnStage(editor, assetRecord, frameNum, displayName, makeClip = false, svgDims = null) { // FIX
    debugLog("placeSvgAssetOnStage START", { assetName: assetRecord?.name, frame: frameNum });

    try {
      const project = editor?.project;
      if (!project || !assetRecord) throw new Error("missing project or asset");

      const uuid = assetRecord.uuid || assetRecord._uuid;
      if (!uuid) throw new Error("asset missing uuid");

      const targetFrameNum = Math.max(1, Number(frameNum) || 1);
      setPlayhead(editor, targetFrameNum);

      const activeFrame = forceEnsureActiveFrame(editor, targetFrameNum);
      if (!activeFrame) debugLog("Frame ensure failed - proceeding anyway");

      const center = getStageCenter(editor);
      debugLog("Placing clip at stage center", { x: center.x, y: center.y });

      let placed = null; // FIX
      for (let attempt = 0; attempt < 20; attempt++) { // FIX
        try { // FIX
          placed = await placeImagePathFromAsset(project, uuid, center.x, center.y); // FIX
          if (placed) break; // FIX
        } catch (e) { // FIX
          const msg = (e && (e.message || String(e))) || ""; // FIX
          debugLog("Placement attempt failed", { attempt: attempt + 1, message: msg }); // FIX
        } // FIX
        await sleepMs(100); // FIX
      } // FIX

      if (!placed) throw new Error("Placement failed (asset not ready or frame not initialized)"); // FIX

      debugLog("Clip placed", { type: placed.constructor?.name || typeof placed });

      selectSingleObject(editor, placed);
      if (displayName) setSelectedNameOrIdentifier(editor, displayName);

      // ── CENTER INNER CONTENTS ──
      const bridge = window.parent?.LukeToolsBridge;
      if (bridge && bridge.recenterClipContentsOnSelection) {
        debugLog("Calling recenterClipContentsOnSelection...");
        const res = bridge.recenterClipContentsOnSelection();
        debugLog("Recentering result", res || "called (no return value)");
      } else {
        debugLog("WARNING: recenterClipContentsOnSelection not available");
      }

      resizePlacedObjectToTarget(editor, placed, svgDims); // FIX

      try {
        if (project.markAsModified) project.markAsModified();
        if (editor.canvas?.render) editor.canvas.render();
        if (editor.projectDidChange) editor.projectDidChange();
      } catch (e) {
        debugLog("Refresh failed", e.message);
      }

      debugLog("Placement & centering COMPLETE");
      return placed;

    } catch (err) {
      debugLog("Placement FAILED", { message: err.message || String(err) });
      return null;
    }
  }

  function parseSvgDimensions(svgText) { // FIX
    try { // FIX
      const holder = document.createElement("div"); // FIX
      holder.innerHTML = svgText; // FIX
      const svg = holder.querySelector("svg"); // FIX
      if (!svg) return null; // FIX
      const wAttr = svg.getAttribute("width"); // FIX
      const hAttr = svg.getAttribute("height"); // FIX
      function num(v) { // FIX
        if (!v) return NaN; // FIX
        const m = String(v).trim().match(/^([0-9.]+)/); // FIX
        return m ? parseFloat(m[1]) : NaN; // FIX
      } // FIX
      let w = num(wAttr); // FIX
      let h = num(hAttr); // FIX
      const vb = svg.getAttribute("viewBox"); // FIX
      if ((!isFinite(w) || !isFinite(h)) && vb) { // FIX
        const parts = vb.trim().split(/\s+/).map(parseFloat); // FIX
        if (parts.length === 4) { // FIX
          w = parts[2]; // FIX
          h = parts[3]; // FIX
        } // FIX
      } // FIX
      if (!isFinite(w) || !isFinite(h) || w <= 0 || h <= 0) return null; // FIX
      return { w: w, h: h }; // FIX
    } catch (e) { // FIX
      return null; // FIX
    } // FIX
  } // FIX

async function importSvgTextToStage(svgText, displayName, makeClip, assetKey) { // FIX
    makeClip = !!makeClip;
    const editor = getEditor();
    if (!editor) return setStatus('Error: editor not found');

    const project = editor.project;
    if (!project) return setStatus('Error: project not found');

    try {
      setStatus('Sanitizing & importing...');

      const sanitizedResult = sanitizeSvg(svgText);

      debugLog("Sanitized", {
        removedNodes: sanitizedResult.removedNodes,
        removedAttrs: sanitizedResult.removedAttrs
      });

            const clipBase = (displayName || 'Shape').replace(/[^a-z0-9_\-]/gi, '_').replace(/_+/g, '_'); // FIX
      const assetBaseRaw = (assetKey || displayName || 'Shape'); // FIX
      const assetBase = String(assetBaseRaw).replace(/\.svg$/i, '').replace(/\//g, '__').replace(/[^a-z0-9_\-]/gi, '_').replace(/_+/g, '_'); // FIX
      const fileName = assetBase + '.svg'; // FIX


      let importedAsset = findAssetByName(project, fileName);

      if (!importedAsset) {
        const blob = new Blob([sanitizedResult.text], { type: 'image/svg+xml' });
        const file = new File([blob], fileName, { type: 'image/svg+xml' });

        const beforeUUIDs = listAssetUUIDs(project);

        await withSuppressedToasts(editor, async () => {
          if (typeof editor.createAssets === 'function') {
            await editor.createAssets([file], []);
          } else if (typeof project.createAssets === 'function') {
            await project.createAssets([file], []);
          } else {
            throw new Error('No createAssets method');
          }
        });

        importedAsset = await waitForNewAsset(project, beforeUUIDs, fileName);
      }

      if (!importedAsset) throw new Error('Asset import failed');

      const frameNumber = getCurrentFrameNumber(editor) || 1;

      const svgDims = parseSvgDimensions(sanitizedResult.text); // FIX
      const placed = await placeSvgAssetOnStage(editor, importedAsset, frameNumber, clipBase, makeClip, svgDims); // FIX

      if (!placed) {
        setStatus('Imported to assets only (placement failed – check debug)');
        return;
      }

      setStatus(`Done – ${displayName} added as clip. Double-click to edit inner paths.`);
    } catch (err) {
      setStatus('Error: ' + (err?.message || String(err)));
      debugLog("Import failed", err);
    }
  }

  async function fetchSvg(fileOrUrl) { // FIX
    const isUrl = typeof fileOrUrl === "string" && /^https?:\/\//i.test(fileOrUrl); // FIX
    const safePath = String(fileOrUrl || ""); // FIX
    const encodedPath = safePath.split("/").map(encodeURIComponent).join("/"); // FIX
    const url = isUrl ? safePath : (BASE_PATH.replace(/\/$/, "") + "/" + encodedPath); // FIX
    const res = await fetch(url, { cache: "no-store" }); // FIX
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} for ${url}`); // FIX
    return await res.text(); // FIX
  }

  function makeButton(shape) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "shapeBtn";
    btn.title = shape.name;

    btn.addEventListener("click", async () => {
      try {
        setStatus(`Importing ${shape.name}...`);
        btn.disabled = true;
        const rawSvg = await fetchSvg(shape.url ? shape.url : shape.file); // FIX
        await importSvgTextToStage(rawSvg, shape.name, placeAsClip, shape.file); // FIX
      } catch (e) {
        setStatus(`Error: ${e?.message || String(e)}`);
      } finally {
        btn.disabled = false;
      }
    });

    fetchSvg(shape.url ? shape.url : shape.file).then(svgText => { // FIX
      const holder = document.createElement("div");
      holder.innerHTML = svgText;
      const svg = holder.querySelector("svg");
      if (svg) {
        svg.removeAttribute("style"); // FIX
        svg.removeAttribute("width"); // FIX
        svg.removeAttribute("height"); // FIX
        svg.setAttribute("width", "28"); // FIX
        svg.setAttribute("height", "28"); // FIX
        svg.setAttribute("fill", "none"); // FIX
        svg.setAttribute("stroke", "currentColor"); // FIX
        svg.setAttribute("stroke-width", "2"); // FIX
        btn.appendChild(svg);
      } else {
        btn.textContent = shape.name;
      }
    }).catch(() => {
      btn.textContent = shape.name;
    });

    return btn;
  }


  function renderShapesList(list) { // FIX
    elGrid.innerHTML = ""; // FIX
    (list || []).forEach(s => elGrid.appendChild(makeButton(s))); // FIX
  } // FIX

  function init() { // FIX
    setStatus("Loading"); // FIX
    loadShapeGroupsFromGithub().then(function (groups) { // FIX
      function selectTab(name) { // FIX
        renderShapesList(groups[name] || []); // FIX
        setStatus("Ready"); // FIX
      } // FIX
      buildCategoryTabs(groups, selectTab); // FIX
      const first = Object.keys(groups).sort((a,b)=>{ if (a==="All") return -1; if (b==="All") return 1; if (a==="Root") return -1; if (b==="Root") return 1; return a.localeCompare(b); })[0]; // FIX
      selectTab(first); // FIX
      if ((groups[first] || []).length === 0) { setStatus("No shapes found"); } // FIX
    }); // FIX
  }

  init();
})();
</script>
</body>
</html>
