<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Arrange Shoulder and Elbow (v3)</title>
  <style>
    body{
      font-family: Arial, sans serif;
      margin: 0;
      padding: 16px;
      background: #ffffff;
      color: #111;
    }
    h1{ font-size: 18px; margin: 0 0 10px 0; }
    .row{ margin: 10px 0; }
    .box{
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
    }
    button{
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
      margin-right: 8px;
    }
    button:active{ transform: translateY(1px); }
    input{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #ddd;
      width: 180px;
    }
    .label{ font-weight: bold; }
    .muted{ color: #444; font-size: 13px; }
    pre{
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }
    .grid{
      display: grid;
      grid-template-columns: 170px 1fr;
      gap: 10px;
      align-items: center;
    }
  </style>
</head>
<body>
  <h1>Arrange Shoulder_R and Elbow_R inside the Selected Clip</h1>

  <div class="row box">
    <div class="row"><span class="label">Selected clip</span>: <span id="selName">(none)</span></div>
    <div class="row muted">
      Targets ONLY the currently selected clip in Wick.
      Then finds the two child clip instances by either their instance name OR their clip asset name.
      Moves contents inside each child so top center becomes 0,0, then stacks:
      Shoulder at 0,0 and Elbow below it.
    </div>

    <div class="row grid">
      <div class="label">Shoulder name</div>
      <div><input id="shoulderName" value="Shoulder_R"></div>

      <div class="label">Elbow name</div>
      <div><input id="elbowName" value="Elbow_R"></div>

      <div class="label">Overlap px</div>
      <div><input id="overlap" value="0"></div>
    </div>

    <div class="row">
      <button id="btnRefresh" type="button">Refresh selection</button>
      <button id="btnArrange" type="button">Arrange</button>
    </div>
  </div>

  <div class="row box">
    <div class="row"><span class="label">Log</span></div>
    <pre id="log"></pre>
  </div>

<script>
(function () {
  "use strict";

  function el(id){ return document.getElementById(id); }
  var logEl = el("log");

  function clearLog(){ logEl.textContent = ""; }
  function logLine(msg){ logEl.textContent += String(msg === undefined ? "" : msg) + "\n"; }

  function s(v){
    if (v === null || v === undefined) return "";
    return String(v);
  }

  function tidy(v){
    return s(v).replace(/\s+/g, " ").trim();
  }

  function toFiniteNumber(v){
    var n = Number(v);
    if (!isFinite(n)) return null;
    return n;
  }

  function toNum(v, fallback){
    var n = toFiniteNumber(v);
    if (n === null) return fallback;
    return n;
  }

  function getBridge(){
    try{ if (window.LukeToolsBridge) return window.LukeToolsBridge; }catch(e1){}
    try{ if (window.parent && window.parent.LukeToolsBridge) return window.parent.LukeToolsBridge; }catch(e2){}
    return null;
  }

  function getEditor(){
    try { if (window.wickEditor) return window.wickEditor; } catch (e1) {}
    try { if (window.WickEditor && window.WickEditor.editor) return window.WickEditor.editor; } catch (e2) {}
    try { if (window.editor) return window.editor; } catch (e3) {}
    try { if (window.app) return window.app; } catch (e4) {}

    // iframe case: editor lives on parent window
    try { if (window.parent && window.parent.wickEditor) return window.parent.wickEditor; } catch (e5) {}
    try { if (window.parent && window.parent.WickEditor && window.parent.WickEditor.editor) return window.parent.WickEditor.editor; } catch (e6) {}
    try { if (window.parent && window.parent.editor) return window.parent.editor; } catch (e7) {}
    try { if (window.parent && window.parent.app) return window.parent.app; } catch (e8) {}

    return null;
  }

  function markDirty(ed){
    try{ if (ed && ed.project && typeof ed.project.markAsModified === "function") ed.project.markAsModified(); }catch(e1){}
    try{ if (ed && ed.project) ed.project.unsavedChanges = true; }catch(e2){}
    try{ if (ed && typeof ed.requestRender === "function") ed.requestRender(); }catch(e3){}
    try{ if (ed && ed.renderer && typeof ed.renderer.requestRender === "function") ed.renderer.requestRender(); }catch(e4){}
  }

  function getObjName(obj){
    if (!obj) return "";
    try{
      if (typeof obj.name === "string") return tidy(obj.name);
      if (typeof obj.getName === "function") return tidy(obj.getName());
    }catch(e1){}
    return "";
  }

  function getAssetName(obj){
    if (!obj) return "";
    try{
      if (obj.clipAsset){
        if (typeof obj.clipAsset.name === "string") return tidy(obj.clipAsset.name);
        if (typeof obj.clipAsset.getName === "function") return tidy(obj.clipAsset.getName());
      }
    }catch(e1){}
    try{
      if (obj.asset){
        if (typeof obj.asset.name === "string") return tidy(obj.asset.name);
        if (typeof obj.asset.getName === "function") return tidy(obj.asset.getName());
      }
    }catch(e2){}
    return "";
  }

  function matchesTarget(obj, targetName){
    var t = tidy(targetName);
    if (!t) return false;

    var n1 = getObjName(obj);
    if (n1 && n1 === t) return true;

    var n2 = getAssetName(obj);
    if (n2 && n2 === t) return true;

    return false;
  }

  function refreshSelection(){
    var bridge = getBridge();
    if (!bridge){
      el("selName").textContent = "(bridge missing)";
      return null;
    }

    try{ if (typeof bridge.captureSelectionNow === "function") bridge.captureSelectionNow(); }catch(e1){}

    var name = "";
    try{ if (typeof bridge.getSelectedClipName === "function") name = tidy(bridge.getSelectedClipName()); }catch(e2){}
    el("selName").textContent = name || "(none)";

    try{
      if (typeof bridge.captureSelectionNow === "function"){
        var sel = bridge.captureSelectionNow();
        if (sel && sel.raw) return sel.raw;
      }
    }catch(e3){}

    return null;
  }

  function getTimelineFromAsset(asset){
    if (!asset) return null;
    try{ if (asset.timeline) return asset.timeline; }catch(e1){}
    try{ if (asset._timeline) return asset._timeline; }catch(e2){}
    return null;
  }

  function resolveClipAssetFromObject(obj){
    if (!obj) return null;

    try{ if (obj.clipAsset) return obj.clipAsset; }catch(e1){}
    try{ if (obj.asset) return obj.asset; }catch(e2){}

    if (getTimelineFromAsset(obj)) return obj;
    return null;
  }

  function getLayersFromTimeline(tl){
    if (!tl) return [];
    try{ if (Array.isArray(tl.layers)) return tl.layers; }catch(e1){}
    try{ if (Array.isArray(tl._layers)) return tl._layers; }catch(e2){}
    return [];
  }

  function getFramesFromLayer(layer){
    if (!layer) return [];
    try{ if (Array.isArray(layer.frames)) return layer.frames; }catch(e1){}
    try{ if (Array.isArray(layer._frames)) return layer._frames; }catch(e2){}
    try{ if (Array.isArray(layer.frame)) return layer.frame; }catch(e3){}
    return [];
  }

  function getObjectsFromFrame(fr){
    if (!fr) return [];
    try{ if (Array.isArray(fr.wickObjects)) return fr.wickObjects; }catch(e1){}
    try{ if (Array.isArray(fr.objects)) return fr.objects; }catch(e2){}
    try{ if (Array.isArray(fr.children)) return fr.children; }catch(e3){}
    try{ if (Array.isArray(fr._children)) return fr._children; }catch(e4){}
    return [];
  }

  function collectFramesFromTimeline(tl){
    var frames = [];
    var layers = getLayersFromTimeline(tl);
    for (var i = 0; i < layers.length; i += 1){
      var frs = getFramesFromLayer(layers[i]);
      for (var j = 0; j < frs.length; j += 1){
        if (frs[j]) frames.push(frs[j]);
      }
    }
    return frames;
  }

  function gatherAllObjectsDeep(list){
    var out = [];
    var stack = Array.isArray(list) ? list.slice() : [];
    var seen = new Set();

    function pushIf(o){
      if (!o) return;
      if (seen.has(o)) return;
      seen.add(o);
      out.push(o);
      stack.push(o);
    }

    // seed
    for (var i = 0; i < stack.length; i += 1){
      // nothing
    }

    // We use stack as a queue of "nodes to expand"
    var idx = 0;
    while (idx < stack.length){
      var cur = stack[idx];
      idx += 1;
      if (!cur) continue;

      // Expand common child collections
      try{
        if (Array.isArray(cur.children)){
          for (var c1 = 0; c1 < cur.children.length; c1 += 1) pushIf(cur.children[c1]);
        }
      }catch(e1){}

      try{
        if (Array.isArray(cur.wickObjects)){
          for (var c2 = 0; c2 < cur.wickObjects.length; c2 += 1) pushIf(cur.wickObjects[c2]);
        }
      }catch(e2){}

      try{
        if (Array.isArray(cur.objects)){
          for (var c3 = 0; c3 < cur.objects.length; c3 += 1) pushIf(cur.objects[c3]);
        }
      }catch(e3){}

      try{
        if (Array.isArray(cur._children)){
          for (var c4 = 0; c4 < cur._children.length; c4 += 1) pushIf(cur._children[c4]);
        }
      }catch(e4){}
    }

    // include original list items, preserving order
    var ordered = [];
    var seen2 = new Set();
    for (var j = 0; j < (Array.isArray(list) ? list.length : 0); j += 1){
      var o2 = list[j];
      if (!o2) continue;
      if (seen2.has(o2)) continue;
      seen2.add(o2);
      ordered.push(o2);
    }
    // then any extras discovered
    for (var k = 0; k < out.length; k += 1){
      if (!out[k]) continue;
      if (seen2.has(out[k])) continue;
      seen2.add(out[k]);
      ordered.push(out[k]);
    }

    return ordered;
  }

  function collectAllObjectsInClipAsset(asset){
    var tl = getTimelineFromAsset(asset);
    if (!tl) return [];
    var frames = collectFramesFromTimeline(tl);
    var all = [];
    for (var i = 0; i < frames.length; i += 1){
      var objs = getObjectsFromFrame(frames[i]);
      if (objs && objs.length){
        var deep = gatherAllObjectsDeep(objs);
        for (var j = 0; j < deep.length; j += 1) all.push(deep[j]);
      }
    }
    return all;
  }

  function getXY(obj){
    if (!obj) return null;

    // direct x/y
    var x1 = toFiniteNumber(obj.x);
    var y1 = toFiniteNumber(obj.y);
    if (x1 !== null && y1 !== null) return { x: x1, y: y1, mode: "xy" };

    // transformation
    try{
      if (obj.transformation){
        var x2 = toFiniteNumber(obj.transformation.x);
        var y2 = toFiniteNumber(obj.transformation.y);
        if (x2 !== null && y2 !== null) return { x: x2, y: y2, mode: "transformation" };
      }
    }catch(e1){}

    // transform
    try{
      if (obj.transform){
        var x3 = toFiniteNumber(obj.transform.x);
        var y3 = toFiniteNumber(obj.transform.y);
        if (x3 !== null && y3 !== null) return { x: x3, y: y3, mode: "transform" };
      }
    }catch(e2){}

    return null;
  }

  function setXY(obj, x, y, mode){
    if (!obj) return false;
    var nx = toFiniteNumber(x);
    var ny = toFiniteNumber(y);
    if (nx === null || ny === null) return false;

    if (mode === "xy"){
      obj.x = nx;
      obj.y = ny;
      return true;
    }

    if (mode === "transformation"){
      if (!obj.transformation) obj.transformation = {};
      obj.transformation.x = nx;
      obj.transformation.y = ny;
      return true;
    }

    if (mode === "transform"){
      if (!obj.transform) obj.transform = {};
      obj.transform.x = nx;
      obj.transform.y = ny;
      return true;
    }

    return false;
  }

  function normalizeBounds(b){
    function n(v){ return toFiniteNumber(v); }

    if (!b) return null;

    if (n(b.x) !== null && n(b.y) !== null && n(b.width) !== null && n(b.height) !== null){
      var bx = n(b.x), by = n(b.y), bw = n(b.width), bh = n(b.height);
      return { minX: bx, minY: by, maxX: bx + bw, maxY: by + bh };
    }

    if (n(b.minX) !== null && n(b.minY) !== null && n(b.maxX) !== null && n(b.maxY) !== null){
      return { minX: n(b.minX), minY: n(b.minY), maxX: n(b.maxX), maxY: n(b.maxY) };
    }

    if (n(b.left) !== null && n(b.top) !== null && n(b.right) !== null && n(b.bottom) !== null){
      return { minX: n(b.left), minY: n(b.top), maxX: n(b.right), maxY: n(b.bottom) };
    }

    if (Array.isArray(b) && b.length >= 4 && n(b[0]) !== null && n(b[1]) !== null && n(b[2]) !== null && n(b[3]) !== null){
      return { minX: n(b[0]), minY: n(b[1]), maxX: n(b[2]), maxY: n(b[3]) };
    }

    return null;
  }

  function getObjectBounds(obj){
    if (!obj) return null;

    try{
      if (typeof obj.getBounds === "function"){
        var b1 = normalizeBounds(obj.getBounds());
        if (b1) return b1;
      }
    }catch(e1){}

    try{
      if (typeof obj.getBoundingBox === "function"){
        var b2 = normalizeBounds(obj.getBoundingBox());
        if (b2) return b2;
      }
    }catch(e2){}

    try{
      var b3 = normalizeBounds(obj.bounds);
      if (b3) return b3;
    }catch(e3){}

    try{
      var b4 = normalizeBounds(obj._bounds);
      if (b4) return b4;
    }catch(e4){}

    // fallback: treat as a point at its x/y
    var xy = getXY(obj);
    if (xy) return { minX: xy.x, minY: xy.y, maxX: xy.x, maxY: xy.y };

    return null;
  }

  function computeBounds(objs){
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    var count = 0;

    for (var i = 0; i < objs.length; i += 1){
      var b = getObjectBounds(objs[i]);
      if (!b) continue;
      count += 1;
      if (b.minX < minX) minX = b.minX;
      if (b.minY < minY) minY = b.minY;
      if (b.maxX > maxX) maxX = b.maxX;
      if (b.maxY > maxY) maxY = b.maxY;
    }

    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
    return { minX: minX, minY: minY, maxX: maxX, maxY: maxY, counted: count };
  }

  function moveContentsOfClipAssetToTopCenter(asset){
    var objs = collectAllObjectsInClipAsset(asset);
    if (!objs.length) return { ok: false, reason: "no objects found in clip" };

    var bounds = computeBounds(objs);
    if (!bounds) return { ok: false, reason: "no bounds" };

    var anchorX = (bounds.minX + bounds.maxX) / 2;
    var anchorY = bounds.minY;
    var dx = -anchorX;
    var dy = -anchorY;

    var moved = 0;
    for (var i = 0; i < objs.length; i += 1){
      var xy = getXY(objs[i]);
      if (!xy) continue;
      if (setXY(objs[i], xy.x + dx, xy.y + dy, xy.mode)) moved += 1;
    }

    return { ok: true, moved: moved, dx: dx, dy: dy, counted: bounds.counted };
  }

  function computeClipAssetBounds(asset){
    var objs = collectAllObjectsInClipAsset(asset);
    if (!objs.length) return null;
    return computeBounds(objs);
  }

  function findInstances(containerAsset, targetName){
    var objs = collectAllObjectsInClipAsset(containerAsset);
    var matches = [];
    var seen = new Set();

    for (var i = 0; i < objs.length; i += 1){
      var o = objs[i];
      if (!o) continue;
      if (!matchesTarget(o, targetName)) continue;
      if (seen.has(o)) continue;
      seen.add(o);
      matches.push(o);
    }

    return matches;
  }

  function listAvailableNames(containerAsset, limit){
    limit = limit || 50;
    var objs = collectAllObjectsInClipAsset(containerAsset);
    var names = [];
    var seen = new Set();

    function addName(n){
      n = tidy(n);
      if (!n) return;
      if (seen.has(n)) return;
      seen.add(n);
      names.push(n);
    }

    for (var i = 0; i < objs.length; i += 1){
      addName(getObjName(objs[i]));
      addName(getAssetName(objs[i]));
      if (names.length >= limit) break;
    }

    return names;
  }

  function setInstancesPosition(containerAsset, targetName, x, y){
    var tl = getTimelineFromAsset(containerAsset);
    if (!tl) return { ok: false, reason: "no timeline" };

    var frames = collectFramesFromTimeline(tl);
    if (!frames.length) return { ok: false, reason: "no frames" };

    var changed = 0;

    for (var i = 0; i < frames.length; i += 1){
      var baseObjs = getObjectsFromFrame(frames[i]);
      var objs = gatherAllObjectsDeep(baseObjs);

      for (var k = 0; k < objs.length; k += 1){
        var o = objs[k];
        if (!o) continue;
        if (!matchesTarget(o, targetName)) continue;

        var xy = getXY(o);
        if (!xy) continue;

        if (setXY(o, x, y, xy.mode)) changed += 1;
      }
    }

    return { ok: true, changed: changed };
  }

  function arrange(){
    clearLog();

    var selectionObj = refreshSelection();
    if (!selectionObj){
      logLine("No selection found. Select Arm_R and try again.");
      return;
    }

    var containerAsset = resolveClipAssetFromObject(selectionObj);
    if (!containerAsset){
      logLine("Your selection does not look like a clip (no clipAsset / asset / timeline).");
      return;
    }

    var containerName = getObjName(selectionObj) || getAssetName(selectionObj) || "(selected clip)";
    logLine("Targeting selected clip: " + containerName);

    var shoulderName = tidy(el("shoulderName").value);
    var elbowName = tidy(el("elbowName").value);
    var overlap = toNum(el("overlap").value, 0);

    if (!shoulderName || !elbowName){
      logLine("Please enter both Shoulder and Elbow names.");
      return;
    }

    logLine("Finding: " + shoulderName + " and " + elbowName + " (instance name OR asset name)");

    var shoulderInstances = findInstances(containerAsset, shoulderName);
    var elbowInstances = findInstances(containerAsset, elbowName);

    if (!shoulderInstances.length || !elbowInstances.length){
      if (!shoulderInstances.length) logLine("Not found: " + shoulderName);
      if (!elbowInstances.length) logLine("Not found: " + elbowName);

      var avail = listAvailableNames(containerAsset, 80);
      if (avail.length){
        logLine("");
        logLine("Names I CAN see inside this selected clip (first 80):");
        logLine(avail.join(", "));
      } else {
        logLine("");
        logLine("No readable names found inside this selected clip.");
      }
      return;
    }

    // Resolve clip assets for Shoulder and Elbow (the child clips)
    var shoulderAsset = resolveClipAssetFromObject(shoulderInstances[0]);
    var elbowAsset = resolveClipAssetFromObject(elbowInstances[0]);

    if (!shoulderAsset){
      logLine("Found " + shoulderName + " but could not resolve its clip asset.");
      return;
    }
    if (!elbowAsset){
      logLine("Found " + elbowName + " but could not resolve its clip asset.");
      return;
    }

    logLine("Shift contents of " + shoulderName + " so top center becomes 0,0");
    var shMove = moveContentsOfClipAssetToTopCenter(shoulderAsset);
    if (!shMove.ok){
      logLine("Shoulder shift failed: " + shMove.reason);
      return;
    }
    logLine("  moved objects: " + shMove.moved + " (bounds counted: " + shMove.counted + ")");

    logLine("Shift contents of " + elbowName + " so top center becomes 0,0");
    var elMove = moveContentsOfClipAssetToTopCenter(elbowAsset);
    if (!elMove.ok){
      logLine("Elbow shift failed: " + elMove.reason);
      return;
    }
    logLine("  moved objects: " + elMove.moved + " (bounds counted: " + elMove.counted + ")");

    var shBounds = computeClipAssetBounds(shoulderAsset);
    if (!shBounds){
      logLine("Could not compute shoulder bounds after shifting.");
      return;
    }

    var shoulderHeight = shBounds.maxY - shBounds.minY;
    if (!isFinite(shoulderHeight)) shoulderHeight = 0;

    var elbowY = shoulderHeight - overlap;

    logLine("Place " + shoulderName + " instance at 0,0");
    var shSet = setInstancesPosition(containerAsset, shoulderName, 0, 0);

    logLine("Place " + elbowName + " instance at 0," + elbowY);
    var elSet = setInstancesPosition(containerAsset, elbowName, 0, elbowY);

    markDirty(getEditor());
    logLine("Done.");
    logLine("Shoulder instances updated: " + (shSet.ok ? shSet.changed : 0));
    logLine("Elbow instances updated: " + (elSet.ok ? elSet.changed : 0));
  }

  el("btnRefresh").addEventListener("click", function(){
    clearLog();
    refreshSelection();
    logLine("Refreshed");
  });

  el("btnArrange").addEventListener("click", function(){
    arrange();
  });

  refreshSelection();
})();
</script>

</body>
</html>
