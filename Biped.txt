<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Arm rig arrange v5</title>
  <style>
    body{
      font-family: Arial, sans serif;
      margin: 0;
      padding: 16px;
      background: #ffffff;
      color: #111;
    }
    h1{ font-size: 18px; margin: 0 0 12px 0; }
    .box{
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 12px;
      background: #fafafa;
      margin-bottom: 12px;
    }
    .row{ margin: 8px 0; }
    .label{ font-weight: 700; }
    .muted{ color: #444; font-size: 13px; }
    button{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
      margin-right: 8px;
      margin-top: 6px;
    }
    button:active{ transform: translateY(1px); }
    input{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      width: 260px;
      max-width: 100%;
    }
    pre{
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin: 0;
    }
    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 700px){
      .grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Arrange Shoulder_R and Elbo_R inside selected clip</h1>

  <div class="box">
    <div class="row"><span class="label">Selected clip</span>: <span id="selName">(none)</span></div>
    <div class="row muted">
      Targets children by identifier only. Uses <code>_identifier</code> or <code>_cachedSerializeData.identifier</code>.
      This version also verifies that x and y actually change after writing.
    </div>

    <div class="grid">
      <div>
        <div class="row"><span class="label">Shoulder identifier</span></div>
        <div class="row"><input id="shoulderId" value="Shoulder_R"></div>
      </div>
      <div>
        <div class="row"><span class="label">Elbow identifier</span></div>
        <div class="row"><input id="elbowId" value="Elbo_R"></div>
      </div>
    </div>

    <div class="grid">
      <div>
        <div class="row"><span class="label">Gap below shoulder (px)</span></div>
        <div class="row"><input id="gap" value="0"></div>
      </div>
      <div>
        <div class="row"><span class="label">Optional test nudge (px)</span></div>
        <div class="row"><input id="nudge" value="50"></div>
      </div>
    </div>

    <div class="row">
      <button id="btnRefresh" type="button">Refresh selection</button>
      <button id="btnInspect" type="button">Log current positions</button>
      <button id="btnArrange" type="button">Arrange</button>
      <button id="btnNudgeElbow" type="button">Test nudge elbow right</button>
    </div>
  </div>

  <div class="box">
    <div class="row"><span class="label">Log</span></div>
    <pre id="log"></pre>
  </div>

<script>
(function () {
  "use strict";

  function el(id){ return document.getElementById(id); }
  var logEl = el("log");

  function clearLog(){ logEl.textContent = ""; }
  function logLine(t){ logEl.textContent += String(t === undefined ? "" : t) + "\n"; }

  function s(v){
    if (v === null || v === undefined) return "";
    return String(v);
  }

  function tidy(v){
    return s(v).replace(/\s+/g, " ").trim();
  }

  function num(v, fallback){
    var n = Number(v);
    if (!isFinite(n)) return fallback;
    return n;
  }

  function isFiniteNumber(v){
    return typeof v === "number" && isFinite(v);
  }

  function getBridge(){
    try{ if (window.LukeToolsBridge) return window.LukeToolsBridge; }catch(e1){}
    try{ if (window.parent && window.parent.LukeToolsBridge) return window.parent.LukeToolsBridge; }catch(e2){}
    return null;
  }

  function getEditor(){
    try { if (window.wickEditor) return window.wickEditor; } catch (e1) {}
    try { if (window.WickEditor && window.WickEditor.editor) return window.WickEditor.editor; } catch (e2) {}
    try { if (window.editor) return window.editor; } catch (e3) {}
    try { if (window.app) return window.app; } catch (e4) {}

    try { if (window.parent && window.parent.wickEditor) return window.parent.wickEditor; } catch (e5) {}
    try { if (window.parent && window.parent.WickEditor && window.parent.WickEditor.editor) return window.parent.WickEditor.editor; } catch (e6) {}
    try { if (window.parent && window.parent.editor) return window.parent.editor; } catch (e7) {}
    try { if (window.parent && window.parent.app) return window.parent.app; } catch (e8) {}

    return null;
  }

  function markDirty(ed){
    try{
      if (ed && ed.project && typeof ed.project.markAsModified === "function"){
        ed.project.markAsModified();
      }
    }catch(e1){}
    try{
      if (ed && ed.project){
        ed.project.unsavedChanges = true;
      }
    }catch(e2){}
  }

  function requestRender(ed){
    // Best effort: different editor builds use different flags
    try{
      if (ed && ed.canvas && typeof ed.canvas.requestRender === "function") ed.canvas.requestRender();
    }catch(e1){}
    try{
      if (ed && ed.renderer && typeof ed.renderer.requestRender === "function") ed.renderer.requestRender();
    }catch(e2){}
    try{
      if (ed && ed.project && typeof ed.project.requestRender === "function") ed.project.requestRender();
    }catch(e3){}
    try{
      if (ed && ed.view && typeof ed.view.requestRender === "function") ed.view.requestRender();
    }catch(e4){}
    try{
      if (ed && ed.canvas) ed.canvas.needsRender = true;
    }catch(e5){}
  }

  function getIdentifier(obj){
    if (!obj) return "";
    try{ if (typeof obj._identifier === "string") return tidy(obj._identifier); }catch(e1){}
    try{
      if (obj._cachedSerializeData && typeof obj._cachedSerializeData.identifier === "string"){
        return tidy(obj._cachedSerializeData.identifier);
      }
    }catch(e2){}
    try{ if (typeof obj.identifier === "string") return tidy(obj.identifier); }catch(e3){}
    return "";
  }

  function getUUID(obj){
    if (!obj) return "";
    try{ if (typeof obj._uuid === "string") return tidy(obj._uuid); }catch(e1){}
    try{ if (typeof obj.uuid === "string") return tidy(obj.uuid); }catch(e2){}
    try{ if (typeof obj.UUID === "string") return tidy(obj.UUID); }catch(e3){}
    try{
      if (obj._cachedSerializeData && typeof obj._cachedSerializeData.uuid === "string"){
        return tidy(obj._cachedSerializeData.uuid);
      }
    }catch(e4){}
    return "";
  }

  function getXY(obj){
    if (!obj) return null;

    try{
      if (isFiniteNumber(obj.x) && isFiniteNumber(obj.y)) return { x: obj.x, y: obj.y, mode: "xy" };
    }catch(e1){}

    try{
      if (isFiniteNumber(obj._x) && isFiniteNumber(obj._y)) return { x: obj._x, y: obj._y, mode: "_xy" };
    }catch(e2){}

    try{
      if (obj.transformation && isFiniteNumber(obj.transformation.x) && isFiniteNumber(obj.transformation.y)){
        return { x: obj.transformation.x, y: obj.transformation.y, mode: "transformation" };
      }
    }catch(e3){}

    try{
      if (obj.transform && isFiniteNumber(obj.transform.x) && isFiniteNumber(obj.transform.y)){
        return { x: obj.transform.x, y: obj.transform.y, mode: "transform" };
      }
    }catch(e4){}

    try{
      if (obj._cachedSerializeData && isFiniteNumber(obj._cachedSerializeData.x) && isFiniteNumber(obj._cachedSerializeData.y)){
        return { x: obj._cachedSerializeData.x, y: obj._cachedSerializeData.y, mode: "cached" };
      }
    }catch(e5){}

    return null;
  }

  function setXY(obj, x, y){
    var steps = [];
    var didAny = false;

    function step(name, fn){
      try{
        var ok = fn();
        steps.push(name + " " + (ok ? "ok" : "no"));
        if (ok) didAny = true;
      }catch(e){
        steps.push(name + " error " + s(e));
      }
    }

    step("setPosition", function(){
      if (obj && typeof obj.setPosition === "function"){
        obj.setPosition(x, y);
        return true;
      }
      return false;
    });

    step("setX setY", function(){
      if (obj && typeof obj.setX === "function" && typeof obj.setY === "function"){
        obj.setX(x);
        obj.setY(y);
        return true;
      }
      return false;
    });

    step("x y", function(){
      if (!obj) return false;
      obj.x = x;
      obj.y = y;
      return true;
    });

    step("_x _y", function(){
      if (!obj) return false;
      obj._x = x;
      obj._y = y;
      return true;
    });

    step("transformation", function(){
      if (obj && obj.transformation){
        obj.transformation.x = x;
        obj.transformation.y = y;
        return true;
      }
      return false;
    });

    step("transform", function(){
      if (obj && obj.transform){
        obj.transform.x = x;
        obj.transform.y = y;
        return true;
      }
      return false;
    });

    step("cached x y", function(){
      if (obj && obj._cachedSerializeData){
        obj._cachedSerializeData.x = x;
        obj._cachedSerializeData.y = y;

        // common nested shapes
        if (obj._cachedSerializeData.transform){
          obj._cachedSerializeData.transform.x = x;
          obj._cachedSerializeData.transform.y = y;
        }
        if (obj._cachedSerializeData.transformation){
          obj._cachedSerializeData.transformation.x = x;
          obj._cachedSerializeData.transformation.y = y;
        }
        return true;
      }
      return false;
    });

    step("rebuild cache", function(){
      if (obj && typeof obj._generateCachedSerializeData === "function"){
        obj._generateCachedSerializeData();
        return true;
      }
      if (obj && typeof obj.generateCachedSerializeData === "function"){
        obj.generateCachedSerializeData();
        return true;
      }
      if (obj && typeof obj._updateCachedSerializeData === "function"){
        obj._updateCachedSerializeData();
        return true;
      }
      return false;
    });

    return { didAny: didAny, steps: steps };
  }

  function getTimelineFromClipLike(obj){
    if (!obj) return null;
    try{ if (obj.timeline) return obj.timeline; }catch(e1){}
    try{ if (obj._timeline) return obj._timeline; }catch(e2){}
    return null;
  }

  function getLayersFromTimeline(tl){
    if (!tl) return [];
    try{ if (Array.isArray(tl.layers)) return tl.layers; }catch(e1){}
    try{ if (Array.isArray(tl._layers)) return tl._layers; }catch(e2){}
    return [];
  }

  function getFramesFromLayer(layer){
    if (!layer) return [];
    try{ if (Array.isArray(layer.frames)) return layer.frames; }catch(e1){}
    try{ if (Array.isArray(layer._frames)) return layer._frames; }catch(e2){}
    try{ if (Array.isArray(layer.frame)) return layer.frame; }catch(e3){}
    return [];
  }

  function getObjectsFromFrame(fr){
    if (!fr) return [];
    try{ if (Array.isArray(fr.wickObjects)) return fr.wickObjects; }catch(e1){}
    try{ if (Array.isArray(fr.objects)) return fr.objects; }catch(e2){}
    try{ if (Array.isArray(fr.children)) return fr.children; }catch(e3){}
    try{ if (Array.isArray(fr._children)) return fr._children; }catch(e4){}
    return [];
  }

  function collectChildClipsFromTimeline(tl){
    var layers = getLayersFromTimeline(tl);
    var out = [];
    var seen = new Set();

    for (var i = 0; i < layers.length; i += 1){
      var frames = getFramesFromLayer(layers[i]);
      for (var j = 0; j < frames.length; j += 1){
        var objs = getObjectsFromFrame(frames[j]);
        for (var k = 0; k < objs.length; k += 1){
          var o = objs[k];
          if (!o) continue;

          var isClip = false;
          try{ if (o._classname === "Clip") isClip = true; }catch(e1){}
          try{ if (!isClip && o._cachedSerializeData && o._cachedSerializeData.classname === "Clip") isClip = true; }catch(e2){}

          if (!isClip) continue;
          if (seen.has(o)) continue;
          seen.add(o);
          out.push(o);
        }
      }
    }

    return out;
  }

  function getTimelineOwner(container){
    // If selection is an instance, clipAsset is the editable content.
    // If selection is already the asset, it will have timeline.
    try{
      if (container && container.clipAsset && getTimelineFromClipLike(container.clipAsset)) return container.clipAsset;
    }catch(e1){}
    if (container && getTimelineFromClipLike(container)) return container;
    return container;
  }

  function findChildByIdentifier(containerOwner, wantedIdentifier){
    wantedIdentifier = tidy(wantedIdentifier);
    if (!wantedIdentifier) return null;

    var tl = getTimelineFromClipLike(containerOwner);
    if (!tl) return null;

    var children = collectChildClipsFromTimeline(tl);

    for (var i = 0; i < children.length; i += 1){
      var id = getIdentifier(children[i]);
      if (id === wantedIdentifier) return children[i];
    }

    return null;
  }

  function refreshSelectionUI(){
    var bridge = getBridge();
    var nm = "";
    try{ if (bridge && typeof bridge.getSelectedClipName === "function") nm = tidy(bridge.getSelectedClipName()); }catch(e1){}
    el("selName").textContent = nm || "(none)";
  }

  function getSelectedRaw(){
    var bridge = getBridge();
    if (!bridge) return null;

    try{ if (typeof bridge.captureSelectionNow === "function") bridge.captureSelectionNow(); }catch(e1){}

    try{
      if (typeof bridge.captureSelectionNow === "function"){
        var sel = bridge.captureSelectionNow();
        if (sel && sel.raw) return sel.raw;
      }
    }catch(e2){}

    return null;
  }

  function logPositions(shoulder, elbow){
    var sp = getXY(shoulder);
    var ep = getXY(elbow);
    logLine("Shoulder id " + getIdentifier(shoulder) + " uuid " + getUUID(shoulder));
    logLine("Shoulder pos " + (sp ? (sp.x + ", " + sp.y + " mode " + sp.mode) : "unknown"));
    logLine("Elbow id " + getIdentifier(elbow) + " uuid " + getUUID(elbow));
    logLine("Elbow pos " + (ep ? (ep.x + ", " + ep.y + " mode " + ep.mode) : "unknown"));
  }

  function arrange(){
    clearLog();

    var shoulderId = tidy(el("shoulderId").value);
    var elbowId = tidy(el("elbowId").value);
    var gap = num(el("gap").value, 0);

    var selected = getSelectedRaw();
    if (!selected){
      logLine("No selected clip object");
      return;
    }

    var owner = getTimelineOwner(selected);
    var tl = getTimelineFromClipLike(owner);
    if (!tl){
      logLine("Selected clip has no timeline");
      return;
    }

    var shoulder = findChildByIdentifier(owner, shoulderId);
    var elbow = findChildByIdentifier(owner, elbowId);

    if (!shoulder){
      logLine("Shoulder not found " + shoulderId);
      return;
    }
    if (!elbow){
      logLine("Elbow not found " + elbowId);
      return;
    }

    var sp0 = getXY(shoulder);
    var ep0 = getXY(elbow);

    if (!sp0 || !ep0){
      logLine("Could not read positions");
      logPositions(shoulder, elbow);
      return;
    }

    logLine("Before");
    logPositions(shoulder, elbow);
    logLine("");

    // Arrange rule:
    // - align elbow x to shoulder x
    // - move elbow down so it is clearly different, even if we cannot compute sizes
    //   Use current delta + gap + 100 as a minimum visible change.
    var minMove = 120;
    var desiredElbowX = sp0.x;
    var desiredElbowY = sp0.y + Math.max(minMove, Math.abs(ep0.y - sp0.y) + gap);

    var setRes = setXY(elbow, desiredElbowX, desiredElbowY);
    logLine("Write steps " + setRes.steps.join(" | "));

    // Verify
    var ep1 = getXY(elbow);
    logLine("After write elbow readback " + (ep1 ? (ep1.x + ", " + ep1.y + " mode " + ep1.mode) : "unknown"));

    var ok = false;
    if (ep1){
      var dx = Math.abs(ep1.x - desiredElbowX);
      var dy = Math.abs(ep1.y - desiredElbowY);
      ok = (dx < 0.01 && dy < 0.01);
    }

    if (!ok){
      logLine("");
      logLine("Position did not stick");
      logLine("Desired elbow " + desiredElbowX + ", " + desiredElbowY);
      logLine("This usually means Wick is storing position somewhere else for this object.");
      logLine("If you run the inspector v3, look for any numeric fields like _cachedSerializeData.x or transformation.x and tell me which ones exist.");
    } else {
      logLine("");
      logLine("Success");
      markDirty(getEditor());
      requestRender(getEditor());
    }

    logLine("");
    logLine("After");
    logPositions(shoulder, elbow);
  }

  function nudgeElbow(){
    clearLog();

    var shoulderId = tidy(el("shoulderId").value);
    var elbowId = tidy(el("elbowId").value);
    var nudge = num(el("nudge").value, 50);

    var selected = getSelectedRaw();
    if (!selected){
      logLine("No selected clip object");
      return;
    }

    var owner = getTimelineOwner(selected);
    var tl = getTimelineFromClipLike(owner);
    if (!tl){
      logLine("Selected clip has no timeline");
      return;
    }

    var elbow = findChildByIdentifier(owner, elbowId);
    var shoulder = findChildByIdentifier(owner, shoulderId);

    if (!elbow){
      logLine("Elbow not found " + elbowId);
      return;
    }

    var ep0 = getXY(elbow);
    if (!ep0){
      logLine("Cannot read elbow position");
      return;
    }

    logLine("Before elbow " + ep0.x + ", " + ep0.y + " mode " + ep0.mode);

    var desiredX = ep0.x + nudge;
    var desiredY = ep0.y;

    var setRes = setXY(elbow, desiredX, desiredY);
    logLine("Write steps " + setRes.steps.join(" | "));

    var ep1 = getXY(elbow);
    logLine("After elbow " + (ep1 ? (ep1.x + ", " + ep1.y + " mode " + ep1.mode) : "unknown"));

    markDirty(getEditor());
    requestRender(getEditor());

    if (shoulder){
      logLine("");
      logLine("Shoulder for reference " + getIdentifier(shoulder) + " uuid " + getUUID(shoulder));
    }
  }

  el("btnRefresh").addEventListener("click", function(){
    clearLog();
    refreshSelectionUI();
    logLine("Refreshed");
  });

  el("btnInspect").addEventListener("click", function(){
    clearLog();
    refreshSelectionUI();

    var selected = getSelectedRaw();
    if (!selected){
      logLine("No selection");
      return;
    }

    var owner = getTimelineOwner(selected);
    var tl = getTimelineFromClipLike(owner);
    if (!tl){
      logLine("Selected clip has no timeline");
      return;
    }

    var shoulder = findChildByIdentifier(owner, tidy(el("shoulderId").value));
    var elbow = findChildByIdentifier(owner, tidy(el("elbowId").value));

    if (!shoulder) logLine("Shoulder not found");
    if (!elbow) logLine("Elbow not found");

    if (shoulder && elbow){
      logPositions(shoulder, elbow);
    }
  });

  el("btnArrange").addEventListener("click", function(){
    refreshSelectionUI();
    arrange();
  });

  el("btnNudgeElbow").addEventListener("click", function(){
    refreshSelectionUI();
    nudgeElbow();
  });

  refreshSelectionUI();
})();
</script>
</body>
</html>
