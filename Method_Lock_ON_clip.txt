To "lock on" to a clip and update it, your tool follows a specific sequence that bridges the gap between the external tool (like Lip Service) and the internal Wick Editor state.
Based on the code in your bridge and the Lip Service tool, here is the exact method used:
1. The "Locking On" Phase (Synchronization)
The tool identifies the target clip by constantly polling the editor's state through a "Sync" loop.
Bridge Detection: The tool first attempts to find the bridge object by checking several global locations (window.wickEditor, window.app, or window.parent.LukeToolsBridge) .
Clip Metadata Retrieval: Once the bridge is found, the tool calls selectionInfo() to get the currently selected object's name, uuid, and _identifier.
Polling Interval: A setInterval (running every 250ms) triggers syncOnce(). This function updates an input field (e.g., inp-clipname) with the name of the clip currently selected in the Wick Editor.
+1
LocalStorage Backup: The selected clip's name and UUID are mirrored in localStorage keys like LukeToolsSelectedClipName. This acts as a fallback if the direct bridge connection is interrupted.
+1
2. The "Updating" Phase (Applying Changes)
Updating the clip involves pushing data from the tool back into the Wick Editor's project structure.
Data Preparation: In tools like Lip Service, clicking "Update Wick" prepares a payload (such as a frame-map or script) and writes it to specialized localStorage keys like wick-lipsync-frame-map.
Script Injection: To update the actual behavior of the clip, the bridge uses functions to:
Find the Target Script: It looks for the update or default script within the object's scripts array.
Overwrite Source: It replaces the src property of the script with the new code generated by the tool.
Ensuring Persistence (Keyframes): The bridge includes a tryEnsureKeyframe() function. Before applying updates that affect the timeline, it checks for an existing keyframe at the current playhead or forces one using internal methods like addKeyframe or insertKeyframe .
Finalizing the Update (Marking Dirty): To ensure the changes are visible and saved, the bridge calls markDirty(). This sets project.unsavedChanges = true and triggers canvas.render() to refresh the editor's view .
Summary of Function Expectations
If you were to standardize this for other tools, the "rules" would be:
Poll for Selection: Use a loop to keep the tool's target clip in sync with the editor's selection.
Verify UUID: Always use the uuid for the actual update to ensure you don't accidentally edit a different clip with the same name.
Handle the Inspector: If updating numerical values (like rotation), use setInspectorNumber to simulate a user typing into the editor's UI, which ensures all internal change events are fired .


Force Refresh: Always call the project's modification flag after an update to prevent data loss
